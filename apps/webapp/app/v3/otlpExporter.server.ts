import { SemanticResourceAttributes } from "@opentelemetry/semantic-conventions";
import { SemanticInternalAttributes } from "@trigger.dev/core/v3";
import {
  AnyValue,
  ExportLogsServiceRequest,
  ExportLogsServiceResponse,
  ExportTraceServiceRequest,
  ExportTraceServiceResponse,
  KeyValue,
  ResourceSpans,
  Span,
  Span_SpanKind,
  Status,
  Status_StatusCode,
  Span_Event,
  Span_Link,
} from "@trigger.dev/otlp-importer";
import { logger } from "~/services/logger.server";
import {
  type CreatableEvent,
  EventRepository,
  CreatableEventKind,
  CreatableEventStatus,
} from "./eventRepository.server";

export type OTLPExporterConfig = {
  batchSize: number;
  batchInterval: number;
};

type DynamicFlushSchedulerConfig<T> = {
  batchSize: number;
  flushInterval: number;
  callback: (batch: T[]) => Promise<void>;
};

class DynamicFlushScheduler<T> {
  private batchQueue: T[][]; // Adjust the type according to your data structure
  private currentBatch: T[]; // Adjust the type according to your data structure
  private readonly BATCH_SIZE: number;
  private readonly FLUSH_INTERVAL: number;
  private flushTimer: NodeJS.Timeout | null;
  private readonly callback: (batch: T[]) => Promise<void>;

  constructor(config: DynamicFlushSchedulerConfig<T>) {
    this.batchQueue = [];
    this.currentBatch = [];
    this.BATCH_SIZE = config.batchSize;
    this.FLUSH_INTERVAL = config.flushInterval;
    this.callback = config.callback;
    this.flushTimer = null;
    this.startFlushTimer();
  }

  addToBatch(items: T[]): void {
    this.currentBatch.push(...items);

    if (this.currentBatch.length >= this.BATCH_SIZE) {
      this.batchQueue.push(this.currentBatch);
      this.currentBatch = [];
      this.flushNextBatch();
      this.resetFlushTimer();
    }
  }

  private startFlushTimer(): void {
    this.flushTimer = setInterval(() => this.checkAndFlush(), this.FLUSH_INTERVAL);
  }

  private resetFlushTimer(): void {
    if (this.flushTimer) {
      clearInterval(this.flushTimer);
    }
    this.startFlushTimer();
  }

  private checkAndFlush(): void {
    if (this.currentBatch.length > 0) {
      this.batchQueue.push(this.currentBatch);
      this.currentBatch = [];
    }
    this.flushNextBatch();
  }

  private async flushNextBatch(): Promise<void> {
    if (this.batchQueue.length === 0) return;

    const batchToFlush = this.batchQueue.shift();
    try {
      await this.callback(batchToFlush!);
      if (this.batchQueue.length > 0) {
        this.flushNextBatch();
      }
    } catch (error) {
      console.error("Error inserting batch:", error);
    }
  }
}

/// Step 1: Filter out spans and logs that aren't generated by us
/// Step 2: Convert spans and logs to a common "Event" format
/// Step 3: Add the events to the batch queue
/// Step 4: When the batch queue is flushed, combine placeholder span events with their corresponding real span events if they are in the same batch
/// Step 5: Insert the batch into the database
/// Other things to do:
/// Make sure to handle flushing the batch queue when the server is shutting down
class OTLPExporter {
  private readonly _flushScheduler: DynamicFlushScheduler<CreatableEvent>;
  private readonly _eventRepository: EventRepository;

  constructor(private readonly _config: OTLPExporterConfig) {
    this._flushScheduler = new DynamicFlushScheduler({
      batchSize: _config.batchSize,
      flushInterval: _config.batchInterval,
      callback: this.#flushBatch.bind(this),
    });

    this._eventRepository = new EventRepository();
  }

  async #flushBatch(batch: CreatableEvent[]): Promise<void> {
    const insertableEvents = excludePartialEventsWithCorrespondingFullEvent(batch);

    logger.info("Flushing batch", {
      batch: batch.length,
      insertableEvents: insertableEvents.length,
    });

    await this._eventRepository.insertMany(insertableEvents);
  }

  async exportTraces(request: ExportTraceServiceRequest): Promise<ExportTraceServiceResponse> {
    this.#filterResourceSpans(request.resourceSpans).map((resourceSpan) => {
      const events = this.#convertToCreateableEvents(resourceSpan);

      logger.info("Received events", {
        events: events.length,
      });

      this._flushScheduler.addToBatch(excludePartialEventsWithCorrespondingFullEvent(events));
    });

    return ExportTraceServiceResponse.create();
  }

  async exportLogs(request: ExportLogsServiceRequest): Promise<ExportLogsServiceResponse> {
    request.resourceLogs.forEach((resourceLog) => {
      const logRecords = resourceLog.scopeLogs.flatMap((scopeLog) => {
        return scopeLog.logRecords;
      });

      logRecords.forEach((logRecord) => {
        logger.info("Received log record", {
          traceId: Buffer.from(Array.from(logRecord.traceId)).toString("hex"),
          spanId: Buffer.from(Array.from(logRecord.spanId)).toString("hex"),
          body: logRecord.body,
          observedTs: logRecord.timeUnixNano,
          attributes: logRecord.attributes,
          schemaUrl: resourceLog.schemaUrl,
          resource: resourceLog.resource
            ? {
                attributes: resourceLog.resource.attributes,
              }
            : null,
        });
      });
    });

    return ExportLogsServiceResponse.create();
  }

  #filterResourceSpans(
    resourceSpans: ExportTraceServiceRequest["resourceSpans"]
  ): ExportTraceServiceRequest["resourceSpans"] {
    return resourceSpans.filter((resourceSpan) => {
      const triggerAttribute = resourceSpan.resource?.attributes.find(
        (attribute) => attribute.key === SemanticInternalAttributes.TRIGGER
      );

      return isBoolValue(triggerAttribute?.value) ? triggerAttribute.value.value.boolValue : false;
    });
  }

  #filterResourceLogs(
    resourceLogs: ExportLogsServiceRequest["resourceLogs"]
  ): ExportLogsServiceRequest["resourceLogs"] {
    return resourceLogs.filter((resourceLog) => {
      const attribute = resourceLog.resource?.attributes.find(
        (attribute) => attribute.key === SemanticInternalAttributes.TRIGGER
      );

      return isBoolValue(attribute?.value) ? attribute.value.value.boolValue : false;
    });
  }

  #convertToCreateableEvents(resourceSpan: ResourceSpans): Array<CreatableEvent> {
    const resourceProperties = {
      metadata: convertKeyValueItemsToMap(resourceSpan.resource?.attributes ?? [], [
        SemanticInternalAttributes.TRIGGER,
      ]),
      serviceName: extractStringAttribute(
        resourceSpan.resource?.attributes ?? [],
        SemanticResourceAttributes.SERVICE_NAME,
        "unknown"
      ),
      serviceNamespace: extractStringAttribute(
        resourceSpan.resource?.attributes ?? [],
        SemanticResourceAttributes.SERVICE_NAMESPACE,
        "unknown"
      ),
      environmentId: extractStringAttribute(
        resourceSpan.resource?.attributes ?? [],
        SemanticInternalAttributes.ENVIRONMENT_ID,
        "unknown"
      ),
      environmentType: extractStringAttribute(
        resourceSpan.resource?.attributes ?? [],
        SemanticInternalAttributes.ENVIRONMENT_TYPE,
        "unknown"
      ) as CreatableEvent["environmentType"],
      organizationId: extractStringAttribute(
        resourceSpan.resource?.attributes ?? [],
        SemanticInternalAttributes.ORGANIZATION_ID,
        "unknown"
      ),
      projectId: extractStringAttribute(
        resourceSpan.resource?.attributes ?? [],
        SemanticInternalAttributes.PROJECT_ID,
        "unknown"
      ),
      projectRef: extractStringAttribute(
        resourceSpan.resource?.attributes ?? [],
        SemanticInternalAttributes.PROJECT_REF,
        "unknown"
      ),
      runId: extractStringAttribute(
        resourceSpan.resource?.attributes ?? [],
        SemanticInternalAttributes.RUN_ID,
        "unknown"
      ),
      taskSlug: extractStringAttribute(
        resourceSpan.resource?.attributes ?? [],
        SemanticInternalAttributes.TASK_SLUG,
        "unknown"
      ),
      taskPath: extractStringAttribute(
        resourceSpan.resource?.attributes ?? [],
        SemanticInternalAttributes.TASK_PATH,
        "unknown"
      ),
      taskExportName: extractStringAttribute(
        resourceSpan.resource?.attributes ?? [],
        SemanticInternalAttributes.TASK_EXPORT_NAME,
        "unknown"
      ),
    };

    return resourceSpan.scopeSpans.flatMap((scopeSpan) => {
      return scopeSpan.spans.map((span) => {
        const isPartial = isPartialSpan(span);

        return {
          traceId: binaryToHex(span.traceId),
          spanId: isPartial
            ? extractStringAttribute(
                span?.attributes ?? [],
                SemanticInternalAttributes.SPAN_ID,
                binaryToHex(span.spanId)
              )
            : binaryToHex(span.spanId),
          parentId: binaryToHex(span.parentSpanId),
          message: span.name,
          isPartial,
          kind: spanKindToEventKind(span.kind),
          level: "TRACE",
          status: spanStatusToEventStatus(span.status),
          startTime: convertUnixNanoToDate(span.startTimeUnixNano),
          links: spanLinksToEventLinks(span.links ?? []),
          events: spanEventsToEventEvents(span.events ?? []),
          duration: span.endTimeUnixNano - span.startTimeUnixNano,
          properties: {
            ...convertKeyValueItemsToMap(span.attributes ?? [], [
              SemanticInternalAttributes.SPAN_ID,
              SemanticInternalAttributes.SPAN_PARTIAL,
            ]),
            ...convertKeyValueItemsToMap(
              resourceSpan.resource?.attributes ?? [],
              [SemanticInternalAttributes.TRIGGER],
              SemanticInternalAttributes.METADATA
            ),
          },
          style: convertKeyValueItemsToMap(
            pickAttributes(span.attributes ?? [], SemanticInternalAttributes.STYLE),
            []
          ),
          output: convertKeyValueItemsToMap(
            pickAttributes(span.attributes ?? [], SemanticInternalAttributes.OUTPUT),
            []
          ),
          ...resourceProperties,
        };
      });
    });
  }
}

/**
 * Filters out partial events from a batch of creatable events, excluding those that have a corresponding full event.
 * @param batch - The batch of creatable events to filter.
 * @returns The filtered array of creatable events, excluding partial events with corresponding full events.
 */
function excludePartialEventsWithCorrespondingFullEvent(batch: CreatableEvent[]): CreatableEvent[] {
  const partialEvents = batch.filter((event) => event.isPartial);
  const fullEvents = batch.filter((event) => !event.isPartial);

  return fullEvents.concat(
    partialEvents.filter((partialEvent) => {
      return !fullEvents.some((fullEvent) => fullEvent.spanId === partialEvent.spanId);
    })
  );
}

function pickAttributes(attributes: KeyValue[], prefix: string): KeyValue[] {
  return attributes
    .filter((attribute) => attribute.key.startsWith(prefix))
    .map((attribute) => {
      return {
        key: attribute.key.replace(`${prefix}.`, ""),
        value: attribute.value,
      };
    });
}

function convertKeyValueItemsToMap(
  attributes: KeyValue[],
  filteredKeys: string[] = [],
  prefix?: string
): Record<string, string | number | boolean | undefined> {
  return attributes.reduce(
    (map: Record<string, string | number | boolean | undefined>, attribute) => {
      if (filteredKeys.includes(attribute.key)) return map;

      map[`${prefix ? `${prefix}.` : ""}${attribute.key}`] = isStringValue(attribute.value)
        ? attribute.value.value.stringValue
        : isIntValue(attribute.value)
        ? Number(attribute.value.value.intValue)
        : isDoubleValue(attribute.value)
        ? attribute.value.value.doubleValue
        : isBoolValue(attribute.value)
        ? attribute.value.value.boolValue
        : isBytesValue(attribute.value)
        ? binaryToHex(attribute.value.value.bytesValue)
        : undefined;

      return map;
    },
    {}
  );
}

function spanLinksToEventLinks(links: Span_Link[]): CreatableEvent["links"] {
  return links.map((link) => {
    return {
      traceId: binaryToHex(link.traceId),
      spanId: binaryToHex(link.spanId),
      tracestate: link.traceState,
      properties: convertKeyValueItemsToMap(link.attributes ?? []),
    };
  });
}

function spanEventsToEventEvents(events: Span_Event[]): CreatableEvent["events"] {
  return events.map((event) => {
    return {
      name: event.name,
      time: convertUnixNanoToDate(event.timeUnixNano),
      properties: convertKeyValueItemsToMap(event.attributes ?? []),
    };
  });
}

function spanStatusToEventStatus(status: Span["status"]): CreatableEventStatus {
  if (!status) return "UNSET";

  switch (status.code) {
    case Status_StatusCode.OK: {
      return "OK";
    }
    case Status_StatusCode.ERROR: {
      return "ERROR";
    }
    case Status_StatusCode.UNSET: {
      return "UNSET";
    }
    default: {
      return "UNSET";
    }
  }
}

function spanKindToEventKind(kind: Span["kind"]): CreatableEventKind {
  switch (kind) {
    case Span_SpanKind.CLIENT: {
      return "CLIENT";
    }
    case Span_SpanKind.SERVER: {
      return "SERVER";
    }
    case Span_SpanKind.CONSUMER: {
      return "CONSUMER";
    }
    case Span_SpanKind.PRODUCER: {
      return "PRODUCER";
    }
    default: {
      return "INTERNAL";
    }
  }
}

function convertUnixNanoToDate(unixNano: bigint): Date {
  return new Date(Number(unixNano / BigInt(1_000_000)));
}

function extractStringAttribute(attributes: KeyValue[], name: string, fallback: string): string {
  const attribute = attributes.find((attribute) => attribute.key === name);

  return isStringValue(attribute?.value) ? attribute.value.value.stringValue : fallback;
}

function isPartialSpan(span: Span): boolean {
  if (!span.attributes) return false;

  const attribute = span.attributes.find(
    (attribute) => attribute.key === SemanticInternalAttributes.SPAN_PARTIAL
  );

  return isBoolValue(attribute?.value) ? attribute.value.value.boolValue : false;
}

function isBoolValue(
  value: AnyValue | undefined
): value is { value: { $case: "boolValue"; boolValue: boolean } } {
  if (!value) return false;

  return (value.value && value.value.$case === "boolValue")!!;
}

function isStringValue(
  value: AnyValue | undefined
): value is { value: { $case: "stringValue"; stringValue: string } } {
  if (!value) return false;

  return (value.value && value.value.$case === "stringValue")!!;
}

function isIntValue(
  value: AnyValue | undefined
): value is { value: { $case: "intValue"; intValue: bigint } } {
  if (!value) return false;

  return (value.value && value.value.$case === "intValue")!!;
}

function isDoubleValue(
  value: AnyValue | undefined
): value is { value: { $case: "doubleValue"; doubleValue: number } } {
  if (!value) return false;

  return (value.value && value.value.$case === "doubleValue")!!;
}

function isBytesValue(
  value: AnyValue | undefined
): value is { value: { $case: "bytesValue"; bytesValue: Buffer } } {
  if (!value) return false;

  return (value.value && value.value.$case === "bytesValue")!!;
}

function binaryToHex(buffer: Buffer): string;
function binaryToHex(buffer: Buffer | undefined): string | undefined;
function binaryToHex(buffer: Buffer | undefined): string | undefined {
  if (!buffer) return undefined;

  return Buffer.from(Array.from(buffer)).toString("hex");
}

export const otlpExporter = new OTLPExporter({
  batchSize: 100,
  batchInterval: 5000,
});

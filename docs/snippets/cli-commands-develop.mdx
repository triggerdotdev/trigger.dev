import ProjectPathArg from '/snippets/cli-args-project-path.mdx';
import CommonOptions from '/snippets/cli-options-common.mdx';
import ProjectRefOption from '/snippets/cli-options-project-ref.mdx';
import EnvFileOption from '/snippets/cli-options-env-file.mdx';
import ConfigFileOption from '/snippets/cli-options-config-file.mdx';
import SkipUpdateCheckOption from '/snippets/cli-options-skip-update-check.mdx';

This runs a server on your machine that can execute Trigger.dev tasks:

<CodeGroup>

```bash npm
npx trigger.dev@latest dev
```

```bash pnpm
pnpm dlx trigger.dev@latest dev
```

```bash yarn
yarn dlx trigger.dev@latest dev
```

</CodeGroup>

It will first perform an update check to prevent version mismatches, failed deploys, and other errors. You will always be prompted first.

You will see in the terminal that the server is running and listening for tasks. When you run a task, you will see it in the terminal along with a link to view it in the dashboard.

It is worth noting that each task runs in a separate Node process. This means that if you have a long-running task, it will not block other tasks from running.

## Options

<ConfigFileOption />

<ProjectRefOption />

<EnvFileOption />

<SkipUpdateCheckOption />

### Common options

These options are available on most commands.

<CommonOptions />

## Concurrently running the terminal

Install the concurrently package as a dev dependency:

```ts
concurrently --raw --kill-others npm:dev:remix npm:dev:trigger
```

Then add something like this in your package.json scripts:

```json
"scripts": {
  "dev": "concurrently --raw --kill-others npm:dev:*",
  "dev:trigger": "npx trigger.dev@latest dev",
  // Add your framework-specific dev script here, for example:
  // "dev:next": "next dev",
  // "dev:remix": "remix dev",
  //...
}
```

---
title: "Wait for HTTP callback"
description: "Pause runs until an HTTP callback is made to the provided URL."
---

import UpgradeToV4Note from "/snippets/upgrade-to-v4-note.mdx";

The `wait.createHttpCallback()` function gives you a callback URL and returns a token representing the waitpoint. You should call a third-party API and provide it with the callback URL so they can notify you when their work is done.

Then you can use `wait.forToken()` to pause the run until the callback URL is hit with a `POST` request.

<UpgradeToV4Note />

## Usage

In this example we create an image using Replicate. Their API accepts a ‚Äúwebhook‚Äù, which is an HTTP POST callback.

```ts
import { logger, task, wait } from "@trigger.dev/sdk";
import Replicate, { Prediction } from "replicate";

export const replicate = task({
  id: "replicate",
  run: async () => {
    const replicate = new Replicate({
      auth: process.env.REPLICATE_API_KEY,
    });

    // 1Ô∏è‚É£ Create the callback URL and token
    const { token, data } = await wait.createHttpCallback(
      async (url) => {
        //   üëÜ This URL continues your run when hit with a POST request

        // 2Ô∏è‚É£ Kick off the long-running job, passing in the URL
        return replicate.predictions.create({
          version: "27b93a2413e7f36cd83da926f3656280b2931564ff050bf9575f1fdf9bcd7478",
          input: {
            prompt: "A painting of a cat by Any Warhol",
          },
          webhook: url, // üëà pass the callback URL
          webhook_events_filter: ["completed"],
        });
      },
      {
        // We'll fail the waitpoint after 10m of inactivity
        timeout: "10m",
        // Tags can be used to filter waitpoints in the dashboard
        tags: ["replicate"],
      }
    );

    logger.log("Create result", { token, data });
    // What you returned from the callback üëÜ

    // 3Ô∏è‚É£ Wait for the callback to be received
    const prediction = await wait.forToken<Prediction>(token);
    if (!prediction.ok) {
      throw new Error("Failed to create prediction");
    }

    logger.log("Prediction", prediction);

    const imageUrl = prediction.output.output;
    logger.log("Image URL", imageUrl);
  },
});
```

## unwrap()

`wait.forToken()` also supports `.unwrap()` which throws if the waitpoint times out,
keeping the happy path clean:

```ts
const prediction = await wait.forToken<Prediction>(token).unwrap();

// This is the result data that Replicate sent back (via HTTP POST)
logger.log("Prediction", prediction);
```

### Options

The `wait.createHttpCallback()` function accepts an optional second parameter with the following properties:

<ParamField query="timeout" type="string" optional>
  The maximum amount of time to wait for the token to be completed.
</ParamField>

<ParamField query="idempotencyKey" type="string" optional>
  An idempotency key for the token. If provided, the token will be completed with the same output if
  the same idempotency key is used again.
</ParamField>

<ParamField query="idempotencyKeyTTL" type="string" optional>
  The time to live for the idempotency key. After this time, the idempotency key will be ignored and
  can be reused to create a new waitpoint.
</ParamField>

<ParamField query="tags" type="string[]" optional>
  Tags to attach to the token. Tags can be used to filter waitpoints in the dashboard.
</ParamField>

### returns

`wait.createHttpCallback()` returns an object with:

<ParamField query="token" type="object">
  Whether the token was completed successfully.

  <Expandable title="properties" defaultOpen={true}>
    <ParamField query="id" type="string">
      The ID of the token. Starts with `waitpoint_`.
    </ParamField>
    <ParamField query="isCached" type="boolean">
      Whether the token is cached. Will return true if the token was created with an idempotency key and
      the same idempotency key was used again.
    </ParamField>

      <ParamField query="url" type="string">
        The URL that was created for the waitpoint. Call this via an HTTP POST request to complete the
        waitpoint and continue the run with the JSON body of the request.
      </ParamField>

  </Expandable>
</ParamField>

<ParamField query="data" type="object">
  If you returned anything from the function, it will be here.
</ParamField>

## Calling the callback URL yourself

`wait.createHttpCallback()` returns a unique one-time-use URL.

You should do a `POST` request to this URL with a text body that is JSON-parseable. If there's no body it will use an empty object `{}`.
